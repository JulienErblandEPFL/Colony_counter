import os
import cv2
import albumentations as A
from tqdm import tqdm
from pathlib import Path
import pandas as pd
from collections import defaultdict

# ================= CONFIGURATION =================
# Path to the data generated by your previous script
INPUT_DIR = os.path.join("data", "cropped_wells")
# Where to save the upsampled data
OUTPUT_DIR = os.path.join("data", "augmented_wells")

# How many new versions to create per original image
AUGMENTATION_FACTOR = 4  
# Add path to CSV containing true values
DATA_CSV = os.path.join("data", "dataset.csv")
# =================================================

def get_augmentation_pipeline():
    """
    Defines the transformations. 
    For circular wells (petri dish/colony), orientation often doesn't matter,
    so Flips and Rotations are mathematically safe.
    """
    return A.Compose([
        A.HorizontalFlip(p=0.5),
        A.VerticalFlip(p=0.5),
        A.RandomRotate90(p=0.9),
    ])

# Helper: assign bin from count value
def _assign_bin(count: float):
    # exclude 0 and -1 (uncountable) and any <=0
    if count == 0:
        return "0"
    if 1 <= count <= 5:
        return "1-5"
    if 5 < count <= 10:
        return "5-10"
    if 10 < count <= 20:
        return "10-20"
    if 20 < count <= 40:
        return "20-40"
    if count > 40:
        return "40+"
    if count == -1:
        return "-1"
    return None

def _load_labels(csv_path: str):
    """
    Load labels from dataset.csv using explicit columns:
    - path: path to image (e.g., data/cropped_wells/.../*.jpg)
    - value: colony count (float/int)
    - is_countable: 1 if countable, 0 otherwise
    Returns dict: rel_path -> (value, is_countable)
    """
    df = pd.read_csv(csv_path)
    required = {"path", "value", "is_countable"}
    missing = required - set(df.columns)
    if missing:
        raise ValueError(f"dataset.csv missing columns: {missing}")
    labels = {}
    for _, row in df.iterrows():
        raw_path = str(row["path"])
        try:
            count = float(row["value"])
            is_countable = int(row["is_countable"])
        except Exception:
            continue
        # Normalize to relative path under INPUT_DIR
        rel = raw_path
        if os.path.isabs(raw_path):
            try:
                rel = os.path.relpath(raw_path, INPUT_DIR)
            except Exception:
                pass
        else:
            # raw_path like 'data/cropped_wells/...'; make relative to INPUT_DIR
            try:
                rel = os.path.relpath(raw_path, INPUT_DIR)
            except Exception:
                pass
        labels[rel] = (count, is_countable)
    return labels

def process_augmentation():
    transform = get_augmentation_pipeline()
    
    # Walk through the directory structure created by your crop script
    image_files = []
    for root, dirs, files in os.walk(INPUT_DIR):
        for file in files:
            if file.lower().endswith(('.png', '.jpg', '.jpeg')):
                abs_path = os.path.join(root, file)
                rel_path = os.path.relpath(abs_path, INPUT_DIR)
                image_files.append((abs_path, rel_path))

    # Load labels and bin images
    labels = _load_labels(DATA_CSV)
    bins = ["0", "1-5", "5-10", "10-20", "20-40", "40+", "-1"]
    NA_BINS = {"0", "-1"}  # bins to NOT augment
    bin_to_images = {b: [] for b in bins}
    eligible_images = []
    for abs_path, rel_path in image_files:
        lbl = labels.get(rel_path)
        if lbl is None:
            continue
        count, is_countable = lbl
        b = _assign_bin(count)
        if b is None:
            continue
        bin_to_images[b].append((abs_path, rel_path))
        # exclude 0 and -1 from augmentation eligibility
        if b not in NA_BINS:
            eligible_images.append((abs_path, rel_path))

    # Print pre-augmentation bin counts
    print("Eligible images per bin (before):")
    for b in bins:
        print(f"  {b}: {len(bin_to_images[b])}")
    print("Note: bins 0 and -1 are excluded from augmentation.")

    # Compute stratified augmentation plan (only augmentable bins)
    total_augs = len(eligible_images) * AUGMENTATION_FACTOR
    non_empty_bins = [b for b in bins if b not in NA_BINS and len(bin_to_images[b]) > 0]
    if not non_empty_bins:
        print("No eligible images to augment based on labels (all are 0 or -1).")
        return
    per_bin_target = total_augs // len(non_empty_bins)
    remainder = total_augs % len(non_empty_bins)

    # Assign per-image augmentation counts within each augmentable bin
    per_image_aug_counts = defaultdict(int)
    # Distribute base target
    for b in non_empty_bins:
        imgs = bin_to_images[b]
        if not imgs:
            continue
        if per_bin_target > 0:
            cycles, extra = divmod(per_bin_target, len(imgs))
            for abs_path, _ in imgs:
                per_image_aug_counts[abs_path] += cycles
            for i in range(extra):
                abs_path, _ = imgs[i]
                per_image_aug_counts[abs_path] += 1
    # Distribute remainder one-by-one across augmentable bins (round-robin)
    if remainder > 0:
        idx = 0
        while remainder > 0:
            b = non_empty_bins[idx % len(non_empty_bins)]
            imgs = bin_to_images[b]
            if imgs:
                abs_path, _ = imgs[idx % len(imgs)]
                per_image_aug_counts[abs_path] += 1
                remainder -= 1
            idx += 1

    # Compute planned augmentations per bin (after)
    planned_bin_augs = {b: 0 for b in bins}
    for b in bins:
        for abs_path, _ in bin_to_images[b]:
            planned_bin_augs[b] += per_image_aug_counts.get(abs_path, 0)

    print("Planned augmentations per bin (after):")
    for b in bins:
        print(f"  {b}: {planned_bin_augs[b]}")

    print(f"Found {len(image_files)} original images. Eligible for stratified augmentation: {len(eligible_images)}")
    print(f"Total augmentations to generate (stratified): {sum(per_image_aug_counts.values())}")

    # Save originals and generate stratified augmentations
    for abs_path, rel_path in tqdm(image_files, desc="Augmenting"):
        try:
            image = cv2.imread(abs_path)
            if image is None:
                continue
            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

            parent_folder = os.path.dirname(rel_path)
            save_folder = os.path.join(OUTPUT_DIR, parent_folder)
            os.makedirs(save_folder, exist_ok=True)

            base_name = os.path.splitext(os.path.basename(abs_path))[0]
            original_save_path = os.path.join(save_folder, f"{base_name}_orig.jpg")
            cv2.imwrite(original_save_path, cv2.cvtColor(image, cv2.COLOR_RGB2BGR))

            # Determine how many augmentations to generate for this image
            num_augs = per_image_aug_counts.get(abs_path, 0)

            for i in range(num_augs):
                augmented = transform(image=image)['image']
                augmented_bgr = cv2.cvtColor(augmented, cv2.COLOR_RGB2BGR)
                save_name = f"{base_name}_aug_{i}.jpg"
                cv2.imwrite(os.path.join(save_folder, save_name), augmented_bgr)

        except Exception as e:
            print(f"Error augmenting {abs_path}: {e}")

if __name__ == "__main__":
    process_augmentation()